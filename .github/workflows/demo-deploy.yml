name: Live Demo with Ngrok

on:
  workflow_dispatch:
    inputs:
      demo_duration:
        description: 'Demo duration in minutes'
        required: false
        default: '10'
        type: string
      demo_message:
        description: 'Demo description/message'
        required: false
        default: 'Drools UI Demo'
        type: string

# Grant permissions for the workflow to create issues
permissions:
  issues: write
  contents: read

env:
  NODE_VERSION: '22'
  JAVA_VERSION: '17'

jobs:
  live-demo:
    runs-on: ubuntu-latest
    timeout-minutes: 15  # Max 15 minutes to prevent infinite runs
    
    services:
      postgres:
        image: postgres:16-alpine
        env:
          POSTGRES_PASSWORD: postgres
          POSTGRES_USER: postgres
          POSTGRES_DB: rule_engine
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 5432:5432

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up JDK
      uses: actions/setup-java@v4
      with:
        java-version: ${{ env.JAVA_VERSION }}
        distribution: 'temurin'

    - name: Set up Node.js
      uses: actions/setup-node@v4
      with:
        node-version: ${{ env.NODE_VERSION }}
        cache: 'npm'
        cache-dependency-path: frontend/package-lock.json

    - name: Cache Gradle packages
      uses: actions/cache@v3
      with:
        path: |
          ~/.gradle/caches
          ~/.gradle/wrapper
        key: ${{ runner.os }}-gradle-${{ hashFiles('**/*.gradle*', '**/gradle-wrapper.properties') }}
        restore-keys: |
          ${{ runner.os }}-gradle-

    # Install ngrok
    - name: Install ngrok
      run: |
        curl -s https://ngrok-agent.s3.amazonaws.com/ngrok.asc | sudo tee /etc/apt/trusted.gpg.d/ngrok.asc >/dev/null
        echo "deb https://ngrok-agent.s3.amazonaws.com buster main" | sudo tee /etc/apt/sources.list.d/ngrok.list
        sudo apt update && sudo apt install ngrok
        ngrok config add-authtoken ${{ secrets.NGROK_AUTH_TOKEN }}

    # Build and start backend
    - name: Build Backend
      working-directory: ./backend
      run: |
        chmod +x ./gradlew
        ./gradlew build -x test
        
        # List generated JAR files for debugging
        echo "üìÅ Generated JAR files:"
        ls -la build/libs/
        
        # Check if JAR is executable
        JAR_FILE=$(ls build/libs/*.jar | head -1)
        if [ -f "$JAR_FILE" ]; then
          echo "‚úÖ JAR file found: $JAR_FILE"
          echo "üìä JAR file size: $(du -h "$JAR_FILE")"
        else
          echo "‚ùå No JAR file found in build/libs/"
          exit 1
        fi

    - name: Start Backend in Background
      working-directory: ./backend
      env:
        SPRING_PROFILES_ACTIVE: docker
        SPRING_DATASOURCE_URL: jdbc:postgresql://localhost:5432/rule_engine
        SPRING_DATASOURCE_USERNAME: postgres
        SPRING_DATASOURCE_PASSWORD: postgres
        SPRING_JPA_HIBERNATE_DDL_AUTO: update
        SERVER_PORT: 8080
      run: |
        nohup java -jar build/libs/*.jar > backend.log 2>&1 &
        BACKEND_PID=$!
        echo $BACKEND_PID > backend.pid
        echo "Backend PID: $BACKEND_PID"
        
        # Wait for backend to start with more detailed logging
        timeout=120
        while [ $timeout -gt 0 ]; do
          # Check if process is still running
          if ! kill -0 $BACKEND_PID 2>/dev/null; then
            echo "‚ùå Backend process died. Checking logs..."
            tail -n 20 backend.log
            exit 1
          fi
          
          # Check if health endpoint is available
          if curl -f http://localhost:8080/actuator/health >/dev/null 2>&1; then
            echo "‚úÖ Backend started successfully!"
            curl -s http://localhost:8080/actuator/health | jq '.' || echo "Health check response received"
            break
          fi
          
          echo "‚è≥ Waiting for backend to start... ($timeout seconds left)"
          # Show recent logs for debugging
          if [ $((timeout % 20)) -eq 0 ]; then
            echo "üìã Recent backend logs:"
            tail -n 5 backend.log 2>/dev/null || echo "No logs yet"
          fi
          sleep 3
          timeout=$((timeout-3))
        done
        
        if [ $timeout -eq 0 ]; then
          echo "‚ùå Backend failed to start within timeout"
          echo "üìã Full backend logs:"
          cat backend.log
          exit 1
        fi    # Build frontend first (without backend URL for now)
    - name: Install Frontend Dependencies
      working-directory: ./frontend
      run: npm ci

    - name: Build Frontend
      working-directory: ./frontend
      env:
        NEXT_PUBLIC_API_URL: http://localhost:8080
      run: npm run build

    # Start ngrok for backend first
    # No need to expose backend - Frontend will connect to backend internally

    # Start frontend - it will connect to backend internally
    - name: Start Frontend in Background
      working-directory: ./frontend
      env:
        # Frontend connects to backend locally
        NEXT_PUBLIC_API_URL: http://localhost:8080
      run: |
        nohup npm start > frontend.log 2>&1 &
        echo $! > frontend.pid
        
        # Wait for frontend to start
        timeout=60
        while [ $timeout -gt 0 ]; do
          if curl -f http://localhost:3000 >/dev/null 2>&1; then
            echo "Frontend started successfully!"
            break
          fi
          echo "Waiting for frontend to start... ($timeout seconds left)"
          sleep 2
          timeout=$((timeout-2))
        done

    # Setup frontend ngrok tunnel
    - name: Start Ngrok for Frontend
      run: |
        # Expose frontend only - users access via this URL
        nohup ngrok http 3000 --log=stdout > ngrok-frontend.log 2>&1 &
        sleep 5
        
        # Get frontend URL
        FRONTEND_URL=$(curl -s http://localhost:4040/api/tunnels | jq -r '.tunnels[0].public_url')
        echo "FRONTEND_URL=$FRONTEND_URL" >> $GITHUB_ENV
        echo "Frontend URL: $FRONTEND_URL"
        
        if [ "$FRONTEND_URL" = "null" ] || [ -z "$FRONTEND_URL" ]; then
          echo "Failed to get frontend ngrok URL"
          exit 1
        fi

    # Create GitHub issue with demo URLs
    - name: Create Demo Issue
      id: create_issue
      uses: actions/github-script@v7
      continue-on-error: true
      with:
        script: |
          const demoInfo = `
          # üöÄ Live Demo Available!
          
          **Demo Message:** ${{ github.event.inputs.demo_message }}
          **Duration:** ${{ github.event.inputs.demo_duration }} minutes
          **Started:** ${new Date().toISOString()}
          
          ## üîó Access URLs
          
          ### Frontend (Next.js UI)
          **URL:** ${{ env.FRONTEND_URL }}
          
          **Features:**
          - ‚úÖ Rules Management Interface
          - ‚úÖ Version Control System
          - ‚úÖ Change Request Workflow
          - ‚úÖ WCO Data Processing
          
          ### Backend (Spring Boot API)
          **Status:** Running internally (connected to Frontend)
          
          **Note:** Backend is not exposed publicly - Frontend proxies API calls internally.
          
          ## üìä Sample WCO Data
          
          Test with sample JSON data available in the project:
          - Import Goods Declaration
          - Cargo Report Inventory
          
          ## ‚ö° Quick Test
          
          1. Open Frontend URL
          2. Navigate to Rules section
          3. Create/Edit business rules
          4. Test with WCO sample data
          
          ---
          
          > **‚ö†Ô∏è Important:** This demo will automatically stop in ${{ github.event.inputs.demo_duration }} minutes.
          > The URLs are temporary and will become inactive after the demo ends.
          
          **Workflow Run:** [${{ github.run_number }}](https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }})
          `;
          
          try {
            const { data: issue } = await github.rest.issues.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: `üöÄ Live Demo #${{ github.run_number }} - ${{ github.event.inputs.demo_message }}`,
              body: demoInfo,
              labels: ['demo', 'temporary']
            });
            
            console.log(`‚úÖ Created demo issue: ${issue.html_url}`);
            core.setOutput('issue_url', issue.html_url);
          } catch (error) {
            console.log(`‚ö†Ô∏è Failed to create issue: ${error.message}`);
            console.log(`üìù Demo info will be shown in workflow logs instead`);
            core.setOutput('issue_url', '');
          }

    # Fallback: Output demo URLs in workflow summary if issue creation failed
    - name: Demo URLs Summary
      run: |
        cat << 'EOF' >> $GITHUB_STEP_SUMMARY
        # üöÄ Live Demo Available!
        
        **Demo Message:** ${{ github.event.inputs.demo_message }}
        **Duration:** ${{ github.event.inputs.demo_duration }} minutes
        **Started:** $(date -u +"%Y-%m-%dT%H:%M:%SZ")
        
        ## üîó Access URLs
        
        ### Frontend (Next.js UI)
        **URL:** ${{ env.FRONTEND_URL }}
        
        ### Backend (Spring Boot API)  
        **Status:** Running internally (connected to Frontend)
        
        ## üß™ Quick Test
        
        - Open the Frontend URL above
        - Navigate to Rules section  
        - Backend API calls are handled automatically through the Frontend
        
        ## ‚ö†Ô∏è Important
        This demo will automatically stop in ${{ github.event.inputs.demo_duration }} minutes.
        The URLs are temporary and will become inactive after the demo ends.
        EOF

    # Keep demo alive for specified duration
    - name: Keep Demo Alive
      run: |
        duration_minutes=${{ github.event.inputs.demo_duration }}
        duration_seconds=$((duration_minutes * 60))
        
        echo "üéØ Demo will run for $duration_minutes minutes ($duration_seconds seconds)"
        echo ""
        echo "üåê Frontend: ${{ env.FRONTEND_URL }}"
        echo "üîß Backend:  Running internally (localhost:8080)"
        echo ""
        echo "‚è∞ Demo started at: $(date)"
        echo "‚è∞ Demo will end at: $(date -d "+$duration_minutes minutes" 2>/dev/null || date -v+${duration_minutes}M 2>/dev/null || echo "$(date) + $duration_minutes minutes")"
        echo ""
        echo "üß™ How to test:"
        echo "  1. Open Frontend URL: ${{ env.FRONTEND_URL }}"
        echo "  2. Navigate to Rules section"
        echo "  3. Backend API calls work automatically"
        
        # Keep alive and show logs
        end_time=$(($(date +%s) + duration_seconds))
        while [ $(date +%s) -lt $end_time ]; do
          remaining=$((end_time - $(date +%s)))
          minutes=$((remaining / 60))
          seconds=$((remaining % 60))
          
          echo "‚è≥ Demo running... ${minutes}m ${seconds}s remaining"
          
          # Show recent logs every minute
          if [ $((remaining % 60)) -eq 0 ]; then
            echo "üìã Recent Backend Logs:"
            tail -n 5 ./backend/backend.log || echo "No backend logs"
            echo ""
            echo "üìã Recent Frontend Logs:"
            tail -n 5 ./frontend/frontend.log || echo "No frontend logs"
            echo "---"
          fi
          
          sleep 10
        done
        
        echo "‚è∞ Demo time ended at: $(date)"

    # Cleanup
    - name: Cleanup Demo
      if: always()
      run: |
        echo "üßπ Cleaning up demo..."
        
        # Kill processes
        if [ -f ./backend/backend.pid ]; then
          kill $(cat ./backend/backend.pid) || true
        fi
        if [ -f ./frontend/frontend.pid ]; then
          kill $(cat ./frontend/frontend.pid) || true
        fi
        
        # Kill ngrok processes
        pkill ngrok || true
        
        echo "‚úÖ Cleanup completed"

    # Debug information
    - name: Debug Information
      if: always()
      run: |
        echo "## üîç Debug Information"
        echo "### Process Status:"
        ps aux | grep -E "(java|node|ngrok)" | grep -v grep || echo "No relevant processes found"
        
        echo ""
        echo "### Port Status:"
        netstat -tlnp 2>/dev/null | grep -E ":8080|:3000|:4040|:4041" || echo "No ports found"
        
        echo ""
        echo "### Log Files:"
        for log in backend.log frontend.log ngrok-backend.log ngrok-frontend.log; do
          if [ -f "$log" ]; then
            echo "üìÑ $log (last 10 lines):"
            tail -n 10 "$log"
            echo ""
          fi
        done

    # Final status
    - name: Demo Summary
      if: always()
      run: |
        echo "## üìä Demo Summary"
        echo "**Duration:** ${{ github.event.inputs.demo_duration }} minutes"
        echo "**Frontend URL:** ${{ env.FRONTEND_URL }}"
        echo "**Backend:** Running internally"
        echo "**Status:** Demo completed"
        echo ""
        echo "üéØ **Why both Frontend AND Backend are exposed:**"
        echo "   - Frontend: User interface for rules management"
        echo "   - Backend: REST API for data processing and WCO validation"
        echo "   - Both needed for complete demo functionality"
        echo ""
        echo "Thank you for trying Drools UI Demo! üéâ"