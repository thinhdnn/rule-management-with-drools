name: Live Demo with Ngrok

on:
  workflow_dispatch:
    inputs:
      demo_duration:
        description: 'Demo duration in minutes'
        required: false
        default: '10'
        type: string
      demo_message:
        description: 'Demo description/message'
        required: false
        default: 'Drools UI Demo'
        type: string

# Grant permissions for the workflow to create issues
permissions:
  issues: write
  contents: read

env:
  NODE_VERSION: '22'
  JAVA_VERSION: '21'

jobs:
  live-demo:
    runs-on: ubuntu-latest
    timeout-minutes: 15  # Max 15 minutes to prevent infinite runs
    
    services:
      postgres:
        image: postgres:16-alpine
        env:
          POSTGRES_PASSWORD: postgres
          POSTGRES_USER: postgres
          POSTGRES_DB: rule_engine
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 5432:5432

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up JDK
      uses: actions/setup-java@v4
      with:
        java-version: ${{ env.JAVA_VERSION }}
        distribution: 'temurin'

    - name: Set up Node.js
      uses: actions/setup-node@v4
      with:
        node-version: ${{ env.NODE_VERSION }}
        cache: 'npm'
        cache-dependency-path: frontend/package-lock.json

    - name: Cache Gradle packages
      uses: actions/cache@v3
      with:
        path: |
          ~/.gradle/caches
          ~/.gradle/wrapper
        key: ${{ runner.os }}-gradle-${{ hashFiles('**/*.gradle*', '**/gradle-wrapper.properties') }}
        restore-keys: |
          ${{ runner.os }}-gradle-

    # Install ngrok
    - name: Install ngrok
      run: |
        curl -s https://ngrok-agent.s3.amazonaws.com/ngrok.asc | sudo tee /etc/apt/trusted.gpg.d/ngrok.asc >/dev/null
        echo "deb https://ngrok-agent.s3.amazonaws.com buster main" | sudo tee /etc/apt/sources.list.d/ngrok.list
        sudo apt update && sudo apt install ngrok
        ngrok config add-authtoken ${{ secrets.NGROK_AUTH_TOKEN }}

    # Build and start backend
    - name: Build Backend
      working-directory: ./backend
      run: |
        chmod +x ./gradlew
        ./gradlew clean bootJar -x test
        
        # List generated JAR files for debugging
        echo "üìÅ Generated JAR files:"
        ls -la build/libs/
        
        # Find the executable JAR (should be the only one now)
        EXECUTABLE_JAR=$(ls build/libs/*.jar 2>/dev/null | grep -v plain | head -1)
        if [ -f "$EXECUTABLE_JAR" ]; then
          echo "‚úÖ Executable JAR found: $EXECUTABLE_JAR"
          echo "üìä JAR file size: $(du -h "$EXECUTABLE_JAR")"
          # Check if it has Main-Class in manifest
          unzip -q -c "$EXECUTABLE_JAR" META-INF/MANIFEST.MF | grep -q "Main-Class" && echo "‚úÖ Main-Class found in manifest" || echo "‚ùå No Main-Class in manifest"
        else
          echo "‚ùå No executable JAR file found in build/libs/"
          echo "Available files:"
          ls -la build/libs/ || echo "No files in build/libs/"
          exit 1
        fi

    - name: Start Backend in Background
      working-directory: ./backend
      env:
        SPRING_PROFILES_ACTIVE: docker
        SPRING_DATASOURCE_URL: jdbc:postgresql://localhost:5432/rule_engine
        SPRING_DATASOURCE_USERNAME: postgres
        SPRING_DATASOURCE_PASSWORD: postgres
        SPRING_JPA_HIBERNATE_DDL_AUTO: update
        SERVER_PORT: 8080
      run: |
        # Find the executable JAR (should be the only one now)
        EXECUTABLE_JAR=$(ls build/libs/*.jar 2>/dev/null | head -1)
        if [ ! -f "$EXECUTABLE_JAR" ]; then
          echo "‚ùå No executable JAR found"
          ls -la build/libs/
          exit 1
        fi
        
        echo "üöÄ Starting backend with: $EXECUTABLE_JAR"
        nohup java -jar "$EXECUTABLE_JAR" > backend.log 2>&1 &
        BACKEND_PID=$!
        echo $BACKEND_PID > backend.pid
        echo "Backend PID: $BACKEND_PID"
        
        # Wait for backend to start with more detailed logging
        timeout=120
        while [ $timeout -gt 0 ]; do
          # Check if process is still running
          if ! kill -0 $BACKEND_PID 2>/dev/null; then
            echo "‚ùå Backend process died. Checking logs..."
            tail -n 20 backend.log
            exit 1
          fi
          
          # Check if health endpoint is available
          if curl -f http://localhost:8080/actuator/health >/dev/null 2>&1; then
            echo "‚úÖ Backend started successfully!"
            curl -s http://localhost:8080/actuator/health | jq '.' || echo "Health check response received"
            break
          fi
          
          echo "‚è≥ Waiting for backend to start... ($timeout seconds left)"
          # Show recent logs for debugging
          if [ $((timeout % 20)) -eq 0 ]; then
            echo "üìã Recent backend logs:"
            tail -n 5 backend.log 2>/dev/null || echo "No logs yet"
          fi
          sleep 3
          timeout=$((timeout-3))
        done
        
        if [ $timeout -eq 0 ]; then
          echo "‚ùå Backend failed to start within timeout"
          echo "üìã Full backend logs:"
          cat backend.log
          exit 1
        fi    # Build frontend first (without backend URL for now)
    - name: Install Frontend Dependencies
      working-directory: ./frontend
      run: npm ci



    # Start ngrok for backend first
    # No need to expose backend - Frontend will connect to backend internally

    # Start frontend initially (will be restarted later with backend URL)
    - name: Start Frontend Initially  
      working-directory: ./frontend
      run: |
        echo "üöÄ Starting frontend initially (will restart with backend URL later)"
        nohup npm start > frontend.log 2>&1 &
        echo $! > frontend.pid
        
        # Wait for initial startup
        timeout=30
        while [ $timeout -gt 0 ]; do
          if curl -f http://localhost:3000 >/dev/null 2>&1; then
            echo "‚úÖ Frontend started initially!"
            break
          fi
          echo "‚è≥ Waiting for frontend initial start... ($timeout seconds left)"
          sleep 2
          timeout=$((timeout-2))
        done

    # Setup ngrok tunnels for both backend and frontend
    - name: Start Ngrok Tunnels
      run: |
        # Start backend tunnel
        nohup ngrok http 8080 --log=stdout > ngrok-backend.log 2>&1 &
        BACKEND_NGROK_PID=$!
        echo "Started backend ngrok tunnel for port 8080 (PID: $BACKEND_NGROK_PID)"
        
        # Start frontend tunnel  
        nohup ngrok http 3000 --log=stdout > ngrok-frontend.log 2>&1 &
        FRONTEND_NGROK_PID=$!
        echo "Started frontend ngrok tunnel for port 3000 (PID: $FRONTEND_NGROK_PID)"
        
        # Wait for tunnels to be ready
        echo "‚è≥ Waiting for ngrok tunnels to be ready..."
        sleep 10
        
        # Check if ngrok processes are still running
        if ! kill -0 $BACKEND_NGROK_PID 2>/dev/null; then
          echo "‚ùå Backend ngrok process died"
          cat ngrok-backend.log
          exit 1
        fi
        
        if ! kill -0 $FRONTEND_NGROK_PID 2>/dev/null; then
          echo "‚ùå Frontend ngrok process died"
          cat ngrok-frontend.log
          exit 1
        fi
        
        # Wait for ngrok API to be available
        timeout=30
        while [ $timeout -gt 0 ]; do
          if curl -f http://localhost:4040/api/tunnels >/dev/null 2>&1; then
            echo "‚úÖ Ngrok API is ready"
            break
          fi
          echo "‚è≥ Waiting for ngrok API... ($timeout seconds left)"
          sleep 2
          timeout=$((timeout-2))
        done
        
        # Debug: Show all tunnels
        echo "üîç Debug: All ngrok tunnels:"
        TUNNELS_JSON=$(curl -s http://localhost:4040/api/tunnels)
        echo "$TUNNELS_JSON" | jq '.'
        
        echo ""
        echo "üîç Debug: Tunnel details:"
        echo "$TUNNELS_JSON" | jq '.tunnels[] | {name, proto, public_url, config: .config.addr}'
        
        # Extract backend URL (port 8080)
        BACKEND_URL=$(echo "$TUNNELS_JSON" | jq -r '.tunnels[] | select(.config.addr | contains("8080")) | select(.proto=="https") | .public_url')
        
        # Extract frontend URL (port 3000)  
        FRONTEND_URL=$(echo "$TUNNELS_JSON" | jq -r '.tunnels[] | select(.config.addr | contains("3000")) | select(.proto=="https") | .public_url')
        
        # Fallback: try without HTTPS filter
        if [ "$BACKEND_URL" = "null" ] || [ -z "$BACKEND_URL" ]; then
          BACKEND_URL=$(echo "$TUNNELS_JSON" | jq -r '.tunnels[] | select(.config.addr | contains("8080")) | .public_url' | head -1)
        fi
        
        if [ "$FRONTEND_URL" = "null" ] || [ -z "$FRONTEND_URL" ]; then
          FRONTEND_URL=$(echo "$TUNNELS_JSON" | jq -r '.tunnels[] | select(.config.addr | contains("3000")) | .public_url' | head -1)
        fi
        
        echo "BACKEND_URL=$BACKEND_URL" >> $GITHUB_ENV
        echo "FRONTEND_URL=$FRONTEND_URL" >> $GITHUB_ENV
        
        echo "‚úÖ Backend URL: $BACKEND_URL"
        echo "‚úÖ Frontend URL: $FRONTEND_URL"
        
        if [ "$BACKEND_URL" = "null" ] || [ -z "$BACKEND_URL" ]; then
          echo "‚ùå Failed to get backend ngrok URL"
          echo "Available tunnels:"
          echo "$TUNNELS_JSON" | jq '.tunnels[] | {name, public_url, config}'
          exit 1
        fi
        
        if [ "$FRONTEND_URL" = "null" ] || [ -z "$FRONTEND_URL" ]; then
          echo "‚ùå Failed to get frontend ngrok URL"
          echo "Available tunnels:"
          echo "$TUNNELS_JSON" | jq '.tunnels[] | {name, public_url, config}'
          exit 1
        fi

    # Rebuild frontend with actual backend URL
    - name: Rebuild Frontend with Backend URL
      working-directory: ./frontend
      env:
        NEXT_PUBLIC_API_URL: ${{ env.BACKEND_URL }}
      run: |
        echo "üîÑ Rebuilding frontend with backend URL: ${{ env.BACKEND_URL }}"
        npm run build

    # Restart frontend with new build
    - name: Restart Frontend with Backend URL
      working-directory: ./frontend
      run: |
        # Kill existing frontend process
        if [ -f frontend.pid ]; then
          kill $(cat frontend.pid) || true
          rm frontend.pid
        fi
        
        # Start frontend with backend URL  
        nohup npm start > frontend.log 2>&1 &
        echo $! > frontend.pid
        
        # Wait for frontend to restart
        timeout=30
        while [ $timeout -gt 0 ]; do
          if curl -f http://localhost:3000 >/dev/null 2>&1; then
            echo "‚úÖ Frontend restarted successfully with backend URL!"
            break
          fi
          echo "‚è≥ Waiting for frontend to restart... ($timeout seconds left)"
          sleep 2
          timeout=$((timeout-2))
        done

    # Create GitHub issue with demo URLs
    - name: Create Demo Issue
      id: create_issue
      uses: actions/github-script@v7
      continue-on-error: true
      with:
        script: |
          const demoInfo = `
          # üöÄ Live Demo Available!
          
          **Demo Message:** ${{ github.event.inputs.demo_message }}
          **Duration:** ${{ github.event.inputs.demo_duration }} minutes
          **Started:** ${new Date().toISOString()}
          
          ## üîó Access URLs
          
          ### Frontend (Next.js UI)
          **URL:** ${{ env.FRONTEND_URL }}
          
          **Features:**
          - ‚úÖ Rules Management Interface
          - ‚úÖ Version Control System
          - ‚úÖ Change Request Workflow
          - ‚úÖ WCO Data Processing
          
          ### Backend (Spring Boot API)
          **URL:** ${{ env.BACKEND_URL }}
          
          **Endpoints:**
          - üîó API Base: `${{ env.BACKEND_URL }}/api/v1`
          - üè• Health Check: `${{ env.BACKEND_URL }}/actuator/health`
          - üìä Rules API: `${{ env.BACKEND_URL }}/api/v1/rules`
          
          ## üìä Sample WCO Data
          
          Test with sample JSON data available in the project:
          - Import Goods Declaration
          - Cargo Report Inventory
          
          ## ‚ö° Quick Test
          
          1. Open Frontend URL
          2. Navigate to Rules section
          3. Create/Edit business rules
          4. Test with WCO sample data
          
          ---
          
          > **‚ö†Ô∏è Important:** This demo will automatically stop in ${{ github.event.inputs.demo_duration }} minutes.
          > The URLs are temporary and will become inactive after the demo ends.
          
          **Workflow Run:** [${{ github.run_number }}](https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }})
          `;
          
          try {
            const { data: issue } = await github.rest.issues.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: `üöÄ Live Demo #${{ github.run_number }} - ${{ github.event.inputs.demo_message }}`,
              body: demoInfo,
              labels: ['demo', 'temporary']
            });
            
            console.log(`‚úÖ Created demo issue: ${issue.html_url}`);
            core.setOutput('issue_url', issue.html_url);
          } catch (error) {
            console.log(`‚ö†Ô∏è Failed to create issue: ${error.message}`);
            console.log(`üìù Demo info will be shown in workflow logs instead`);
            core.setOutput('issue_url', '');
          }

    # Fallback: Output demo URLs in workflow summary if issue creation failed
    - name: Demo URLs Summary
      run: |
        cat << 'EOF' >> $GITHUB_STEP_SUMMARY
        # üöÄ Live Demo Available!
        
        **Demo Message:** ${{ github.event.inputs.demo_message }}
        **Duration:** ${{ github.event.inputs.demo_duration }} minutes
        **Started:** $(date -u +"%Y-%m-%dT%H:%M:%SZ")
        
        ## üîó Access URLs
        
        ### Frontend (Next.js UI)
        **URL:** ${{ env.FRONTEND_URL }}
        
        ### Backend (Spring Boot API)  
        **URL:** ${{ env.BACKEND_URL }}
        
        ## üß™ Quick Test
        
        - **Frontend:** Open ${{ env.FRONTEND_URL }} for the UI
        - **Backend:** Test API at ${{ env.BACKEND_URL }}/actuator/health
        - **Integration:** Frontend connects to backend automatically
        
        ## ‚ö†Ô∏è Important
        This demo will automatically stop in ${{ github.event.inputs.demo_duration }} minutes.
        The URLs are temporary and will become inactive after the demo ends.
        EOF

    # Keep demo alive for specified duration
    - name: Keep Demo Alive
      run: |
        duration_minutes=${{ github.event.inputs.demo_duration }}
        duration_seconds=$((duration_minutes * 60))
        
        echo "üéØ Demo will run for $duration_minutes minutes ($duration_seconds seconds)"
        echo ""
        echo "üåê Frontend: ${{ env.FRONTEND_URL }}"
        echo "üîß Backend:  ${{ env.BACKEND_URL }}"
        echo ""
        echo "‚è∞ Demo started at: $(date)"
        echo "‚è∞ Demo will end at: $(date -d "+$duration_minutes minutes" 2>/dev/null || date -v+${duration_minutes}M 2>/dev/null || echo "$(date) + $duration_minutes minutes")"
        echo ""
        echo "üß™ How to test:"
        echo "  1. Frontend UI: ${{ env.FRONTEND_URL }}"
        echo "  2. Backend API: ${{ env.BACKEND_URL }}/actuator/health"
        echo "  3. Rules API: ${{ env.BACKEND_URL }}/api/v1/rules"
        
        # Keep alive and show logs
        end_time=$(($(date +%s) + duration_seconds))
        while [ $(date +%s) -lt $end_time ]; do
          remaining=$((end_time - $(date +%s)))
          minutes=$((remaining / 60))
          seconds=$((remaining % 60))
          
          echo "‚è≥ Demo running... ${minutes}m ${seconds}s remaining"
          
          # Show recent logs every minute
          if [ $((remaining % 60)) -eq 0 ]; then
            echo "üìã Recent Backend Logs:"
            tail -n 5 ./backend/backend.log || echo "No backend logs"
            echo ""
            echo "üìã Recent Frontend Logs:"
            tail -n 5 ./frontend/frontend.log || echo "No frontend logs"
            echo "---"
          fi
          
          sleep 10
        done
        
        echo "‚è∞ Demo time ended at: $(date)"

    # Cleanup
    - name: Cleanup Demo
      if: always()
      run: |
        echo "üßπ Cleaning up demo..."
        
        # Kill processes
        if [ -f ./backend/backend.pid ]; then
          kill $(cat ./backend/backend.pid) || true
        fi
        if [ -f ./frontend/frontend.pid ]; then
          kill $(cat ./frontend/frontend.pid) || true
        fi
        
        # Kill ngrok processes
        pkill ngrok || true
        
        echo "‚úÖ Cleanup completed"

    # Debug information
    - name: Debug Information
      if: always()
      run: |
        echo "## üîç Debug Information"
        echo "### Process Status:"
        ps aux | grep -E "(java|node|ngrok)" | grep -v grep || echo "No relevant processes found"
        
        echo ""
        echo "### Port Status:"
        netstat -tlnp 2>/dev/null | grep -E ":8080|:3000|:4040|:4041" || echo "No ports found"
        
        echo ""
        echo "### Log Files:"
        for log in backend.log frontend.log ngrok-backend.log ngrok-frontend.log; do
          if [ -f "$log" ]; then
            echo "üìÑ $log (last 10 lines):"
            tail -n 10 "$log"
            echo ""
          fi
        done

    # Final status
    - name: Demo Summary
      if: always()
      run: |
        echo "## üìä Demo Summary"
        echo "**Duration:** ${{ github.event.inputs.demo_duration }} minutes"
        echo "**Frontend URL:** ${{ env.FRONTEND_URL }}"
        echo "**Backend URL:** ${{ env.BACKEND_URL }}"
        echo "**Status:** Demo completed"
        echo ""
        echo "üéØ **Demo Architecture:**"
        echo "   - Frontend: Public UI via ngrok tunnel (port 3000)"
        echo "   - Backend: Public API via ngrok tunnel (port 8080)"
        echo "   - Frontend connects to backend via public URLs"
        echo ""
        echo "Thank you for trying Drools UI Demo! üéâ"