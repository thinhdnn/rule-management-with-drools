name: Live Demo with Docker (Self-Hosted)

on:
  workflow_dispatch:
    inputs:
      demo_message:
        description: 'Demo description/message'
        required: false
        default: 'Drools UI Demo (Docker)'
        type: string

# Grant permissions for the workflow to create issues
permissions:
  issues: write
  contents: read

jobs:
  live-demo-docker:
    runs-on: self-hosted
    timeout-minutes: 30  # Build and setup timeout
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Check Prerequisites
      run: |
        echo "üîç Checking prerequisites..."
        
        # Check Docker
        if ! command -v docker &> /dev/null; then
          echo "‚ùå Docker is not installed"
          exit 1
        fi
        echo "‚úÖ Docker: $(docker --version)"
        
        # Check Docker Compose (prioritize V2)
        if ! docker compose version &> /dev/null && ! command -v docker-compose &> /dev/null; then
          echo "‚ùå Docker Compose is not installed"
          exit 1
        fi
        if docker compose version &> /dev/null; then
          echo "‚úÖ Docker Compose: $(docker compose version)"
        else
          echo "‚úÖ Docker Compose: $(docker-compose --version)"
        fi
        
        # Detect architecture
        ARCH=$(uname -m)
        echo "‚úÖ Architecture: $ARCH"
        if [[ "$ARCH" == "aarch64" ]] || [[ "$ARCH" == "arm64" ]]; then
          echo "‚úÖ Running on ARM architecture"
        fi
        
        # Get host IP address
        if [[ "$OSTYPE" == "linux-gnu"* ]]; then
          HOST_IP=$(hostname -I | awk '{print $1}')
        elif [[ "$OSTYPE" == "darwin"* ]]; then
          HOST_IP=$(ipconfig getifaddr en0 || ipconfig getifaddr en1 || echo "localhost")
        else
          HOST_IP="localhost"
        fi
        echo "HOST_IP=$HOST_IP" >> $GITHUB_ENV
        echo "‚úÖ Host IP: $HOST_IP"

    - name: Cleanup Previous Demo
      run: |
        echo "üßπ Cleaning up any previous demo containers..."
        
        # Stop and remove containers (prioritize V2)
        docker compose down -v 2>/dev/null || docker-compose down -v 2>/dev/null || true
        
        # Remove old log files
        rm -f docker-compose.log
        
        echo "‚úÖ Cleanup completed"

    - name: Build and Start Services with Docker Compose
      run: |
        echo "üê≥ Building and starting services with Docker Compose..."
        
        # Use docker compose (V2) or docker-compose (legacy) based on availability
        if docker compose version &> /dev/null; then
          COMPOSE_CMD="docker compose"
        else
          COMPOSE_CMD="docker-compose"
        fi
        
        # Set NEXT_PUBLIC_BACKEND_URL for Docker demo (use HOST_IP for local network)
        # Browser will call backend via http://HOST_IP:9031/be
        export NEXT_PUBLIC_BACKEND_URL="http://${{ env.HOST_IP }}:9031/be"
        echo "üìù NEXT_PUBLIC_BACKEND_URL=$NEXT_PUBLIC_BACKEND_URL (for browser to call backend)"
        
        # Build and start services in detached mode
        # Pass NEXT_PUBLIC_BACKEND_URL to docker-compose via environment
        NEXT_PUBLIC_BACKEND_URL="$NEXT_PUBLIC_BACKEND_URL" $COMPOSE_CMD up -d --build 2>&1 | tee docker-compose.log
        
        echo "‚è≥ Waiting for services to be healthy..."
        
        # Wait for PostgreSQL
        timeout=120
        while [ $timeout -gt 0 ]; do
          if $COMPOSE_CMD ps postgres | grep -q "healthy"; then
            echo "‚úÖ PostgreSQL is healthy"
            break
          fi
          echo "‚è≥ Waiting for PostgreSQL... ($timeout seconds left)"
          sleep 3
          timeout=$((timeout-3))
        done
        
        if [ $timeout -eq 0 ]; then
          echo "‚ùå PostgreSQL failed to start"
          $COMPOSE_CMD logs postgres
          exit 1
        fi
        
        # Wait for Backend
        timeout=180
        while [ $timeout -gt 0 ]; do
          if $COMPOSE_CMD ps backend | grep -q "healthy"; then
            echo "‚úÖ Backend is healthy"
            break
          fi
          echo "‚è≥ Waiting for backend... ($timeout seconds left)"
          sleep 5
          timeout=$((timeout-5))
        done
        
        if [ $timeout -eq 0 ]; then
          echo "‚ùå Backend failed to start"
          $COMPOSE_CMD logs backend
          exit 1
        fi
        
        # Wait for Frontend
        timeout=120
        while [ $timeout -gt 0 ]; do
          if $COMPOSE_CMD ps frontend | grep -q "healthy"; then
            echo "‚úÖ Frontend is healthy"
            break
          fi
          echo "‚è≥ Waiting for frontend... ($timeout seconds left)"
          sleep 5
          timeout=$((timeout-5))
        done
        
        if [ $timeout -eq 0 ]; then
          echo "‚ùå Frontend failed to start"
          $COMPOSE_CMD logs frontend
          exit 1
        fi
        
        echo "‚úÖ All services are running and healthy"
        
        # Show running containers
        echo "üìä Running containers:"
        $COMPOSE_CMD ps

    - name: Verify Services
      run: |
        echo "üîç Verifying services are accessible..."
        
        # Wait a bit for services to be fully ready
        sleep 5
        
        # Test direct access to services
        curl -f http://localhost:9030 >/dev/null && echo "‚úÖ Frontend accessible at http://localhost:9030" || echo "‚ö†Ô∏è Frontend not accessible"
        curl -f http://localhost:9031/actuator/health >/dev/null && echo "‚úÖ Backend accessible at http://localhost:9031" || echo "‚ö†Ô∏è Backend not accessible"
        
        # Set demo URLs based on host IP
        echo "FRONTEND_URL=http://${{ env.HOST_IP }}:9030" >> $GITHUB_ENV
        echo "BACKEND_URL=http://${{ env.HOST_IP }}:9031" >> $GITHUB_ENV
        echo "‚úÖ Services are accessible on host IP: ${{ env.HOST_IP }}"

    - name: Create Demo Issue
      id: create_issue
      uses: actions/github-script@v7
      continue-on-error: true
      with:
        script: |
          const demoInfo = `
          # üöÄ Live Demo Available! (Docker on Self-Hosted)
          
          **Demo Message:** ${{ github.event.inputs.demo_message }}
          **Started:** ${new Date().toISOString()}
          **Environment:** Self-Hosted Runner with Docker
          **Status:** Services running indefinitely (managed by self-hosted runner)
          
          ## üîó Access URLs (Local Network)
          
          ### üåê Demo Application
          **Host IP:** \`${{ env.HOST_IP }}\`
          
          **Services:**
          - ‚úÖ **Frontend UI**: \`${{ env.FRONTEND_URL }}\`
          - ‚úÖ **Backend API**: \`${{ env.BACKEND_URL }}/api/v1\`
          - ‚úÖ **Health Check**: \`${{ env.BACKEND_URL }}/actuator/health\`
          
          **Available Functions:**
          - üìã Rules Management Interface
          - üîÑ Version Control System  
          - üìù Change Request Workflow
          - üåç WCO Data Processing
          
          **API Endpoints:**
          - üìù Rules API: \`${{ env.BACKEND_URL }}/api/v1/rules\`
          - üì¶ Metadata: \`${{ env.BACKEND_URL }}/api/v1/rules/metadata\`
          - üè• Health: \`${{ env.BACKEND_URL }}/actuator/health\`
          
          ## üê≥ Docker Architecture
          
          - **PostgreSQL**: Database container (port 5432)
          - **Spring Boot Backend**: Java application container (port 9031)
          - **Next.js Frontend**: Node.js application container (port 9030)
          - **Network**: All services in Docker bridge network
          - **Platform**: ARM64 (Oracle Cloud)
          
          ## üìä Sample WCO Data
          
          Test with sample JSON data available in the project:
          - Import Goods Declaration
          - Cargo Report Inventory
          
          ## ‚ö° Quick Test
          
          1. Access Frontend URL from your local network
          2. Navigate to Rules section
          3. Create/Edit business rules
          4. Test with WCO sample data
          
          ---
          
          > **‚ö†Ô∏è Important:** 
          > - This demo is accessible only from the local network
          > - Services will run indefinitely until manually stopped
          > - Use GitHub Actions to stop the workflow or manually run cleanup
          
          **Workflow Run:** [${{ github.run_number }}](https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }})
          `;
          
          try {
            const { data: issue } = await github.rest.issues.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: `üê≥ Docker Demo #${{ github.run_number }} - ${{ github.event.inputs.demo_message }}`,
              body: demoInfo,
              labels: ['demo', 'docker', 'self-hosted', 'local-network', 'temporary']
            });
            
            console.log(`‚úÖ Created demo issue: ${issue.html_url}`);
            core.setOutput('issue_url', issue.html_url);
          } catch (error) {
            console.log(`‚ö†Ô∏è Failed to create issue: ${error.message}`);
            core.setOutput('issue_url', '');
          }

    - name: Demo URLs Summary
      run: |
        cat << EOF >> $GITHUB_STEP_SUMMARY
        # üöÄ Live Demo Available! (Docker - Local Network)
        
        **Demo Message:** ${{ github.event.inputs.demo_message }}
        **Started:** $(date -u +"%Y-%m-%dT%H:%M:%SZ")
        **Environment:** Self-Hosted Runner with Docker
        **Status:** Services running indefinitely
        
        ## üîó Access URLs (Local Network)
        
        ### üåê Demo Application
        **Host IP:** ${{ env.HOST_IP }}
        
        ## üß™ Quick Test
        
        - **Frontend UI:** ${{ env.FRONTEND_URL }}
        - **Backend API:** ${{ env.BACKEND_URL }}/actuator/health
        - **Rules API:** ${{ env.BACKEND_URL }}/api/v1/rules
        
        ## üê≥ Docker Architecture
        
        - PostgreSQL Database (port 5432)
        - Spring Boot Backend (port 9031)
        - Next.js Frontend (port 9030)
        - All services in Docker containers
        - Platform: ARM64 (Oracle Cloud)
        - Accessible via local network or Cloudflared tunnel
        
        ## ‚ö†Ô∏è Important
        - Demo is accessible only from the local network
        - Services will run indefinitely until manually stopped
        - Use GitHub Actions to stop the workflow or manually run cleanup
        EOF

    - name: Demo Running
      run: |
        echo "‚úÖ Demo services are now running!"
        echo ""
        echo "üåê Host IP: ${{ env.HOST_IP }}"
        echo "‚è∞ Started at: $(date)"
        echo ""
        echo "üß™ Access URLs (from local network):"
        echo "  1. Frontend UI: ${{ env.FRONTEND_URL }}"
        echo "  2. Backend API: ${{ env.BACKEND_URL }}/actuator/health"  
        echo "  3. Rules API: ${{ env.BACKEND_URL }}/api/v1/rules"
        echo ""
        echo "üìä Services Status:"
        
        # Use docker compose (V2) or docker-compose (legacy) based on availability
        if docker compose version &> /dev/null; then
          COMPOSE_CMD="docker compose"
        else
          COMPOSE_CMD="docker-compose"
        fi
        
        $COMPOSE_CMD ps
        echo ""
        echo "‚ÑπÔ∏è  Services will run indefinitely until manually stopped"
        echo "‚ÑπÔ∏è  To stop: Cancel this workflow or run 'docker compose down' manually"

    - name: Cleanup Demo
      if: failure() || cancelled()
      run: |
        echo "üßπ Cleaning up demo..."
        
        # Use docker compose (V2) or docker-compose (legacy) based on availability
        if docker compose version &> /dev/null; then
          COMPOSE_CMD="docker compose"
        else
          COMPOSE_CMD="docker-compose"
        fi
        
        # Stop and remove containers
        $COMPOSE_CMD down -v
        
        # Clean up log files
        rm -f docker-compose.log
        
        echo "‚úÖ Cleanup completed"

    - name: Debug Information
      if: always()
      run: |
        echo "## üîç Debug Information"
        
        # Use docker compose (V2) or docker-compose (legacy) based on availability
        if docker compose version &> /dev/null; then
          COMPOSE_CMD="docker compose"
        else
          COMPOSE_CMD="docker-compose"
        fi
        
        echo "### Docker Container Status:"
        docker ps -a || echo "No containers found"
        
        echo ""
        echo "### Docker Compose Status:"
        $COMPOSE_CMD ps 2>/dev/null || echo "Docker Compose not running"
        
        echo ""
        echo "### Port Status:"
        netstat -tlnp 2>/dev/null | grep -E ":9030|:9031|:5432" || \
        lsof -i :9030,9031,5432 2>/dev/null || \
        echo "No ports found"
        
        echo ""
        echo "### Docker Logs:"
        if [ -f "docker-compose.log" ]; then
          echo "üìÑ docker-compose.log (last 10 lines):"
          tail -n 10 docker-compose.log
        fi

    - name: Demo Summary
      if: always()
      run: |
        echo "## üìä Demo Summary"
        echo "**Host IP:** ${{ env.HOST_IP }}"
        echo "**Frontend URL:** ${{ env.FRONTEND_URL }}"
        echo "**Backend URL:** ${{ env.BACKEND_URL }}"
        echo "**Environment:** Self-Hosted Runner with Docker"
        echo "**Status:** Services stopped"
        echo ""
        echo "üéØ **Docker Architecture:**"
        echo "   - PostgreSQL: Database in container (port 5432)"
        echo "   - Backend: Spring Boot in container (port 9031)"
        echo "   - Frontend: Next.js in container (port 9030)"
        echo "   - Network: Docker bridge network"
        echo "   - Platform: ARM64 (Oracle Cloud)"
        echo "   - Access: Local network or Cloudflared tunnel"
        echo ""
        echo "Thank you for trying Drools UI Demo with Docker! üéâ"

